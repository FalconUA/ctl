#include "ctlfac.hpp"
#include "ctlmod.hpp"
#include "typespec.hpp"
#include <stdlib.h>
#include <vector>
#include <iostream>
#include <algorithm>

namespace mp {

	template <typename T>
	static void factorize(T const& t, std::vector<T>& res, TypeSpecifications<T> const& algo){
		T r1, r2;
		fac_pollard(t, r1, r2, algo);
		if ((r1!=t)&&(r1!=1)) res.push_back(r1);
		if ((r2!=t)&&(r2!=1)) res.push_back(r2);
		if (!(r1==1 || r2==1)){
			factorize(r1, res, algo);
			factorize(r2, res, algo);
		}
	}

	template <typename T> 
	static T powmod (T a, T b, T p) {
		T res = 1;
		while (b)
			if (b % 2 == 1)
				res = T (res * 1ll * a % p),  --b;
		else
			a = T (a * 1ll * a % p),  b = b/2;
		return res;
	}

	template <typename T>
	static T phi (T n, TypeSpecifications<T> const& algo) {
		T result = n;
		for (T i=2; i*i<=n; ++i)
		if (n % i == 0) {
				while (n % i == 0)
					n /= i;
				result -= result / i;
			}
		if (n > 1)
			result -= result / n;
		return result;
	}

	template <typename T>
	static size_t __phi(T t, TypeSpecifications<T>const& algo){
		size_t result = t;
		std::vector<T> fac({1, t});
		factorize(t, fac, algo);

		for (size_t i=0; i<fac.size(); i++)
			if (fac[i] != 1){
				while (t % i == 0)
					t = t / i;
				result = result - result/i;
			}
		if (t > 1)
			result - result - result/t;
		return result;
	}

	template <typename T>
	T __primitive_root_modulo(T const& n, TypeSpecifications<T> const& algo){

		 //special occasions: n = {2, 4, 4*k(k>1,k<-Z)};
	    if(n == 2) return 1;
	    if(n == 4) return 3;
	    if(n % 4 == 0) return 0;
	    //there remained only occasions: n = {2k+1, 2*(2k+1)};
	    bool ev_numb_n = (n%2 == 0);
	    T t = (ev_numb_n)?(n/2):(n);
		std::cout << t << "\n";
	    T p;
				
		{
			std::vector<T> fact;
			factorize(t, fact, algo);
			if (fact.size() == 0)
				return 0;
			p = fact[0];
		}
		
		std::cout << "wtf?\n";	
	    t = phi(n, algo);
		std::cout << n << " " << t << "\n";

	    std::vector<T> rank_G_factors;
	    factorize(t, rank_G_factors, algo);
		
		std::cout << "here?\n";
	    int m = (int)rank_G_factors.size();
	    //t = p1^k1 * p2^k2 * ... * pm^km;
	    //now rank_G_factors = {p1,...,p1, p2,...,p2, ... , pm,...,pm};
	
		std::cout << "nope...\n";
	    std::vector<T> Group;


	    for(T i = 1, k = ev_numb_n ? 2 : 1 ; i < n; i = i+k)
		    if(i % p != 0)
			    Group.push_back(i);

	    T g,b;
		int group_size = Group.size(), index = 0;

		std::cout << "here maybe?\n";
		std::random_shuffle(Group.begin(), Group.end());
	
		std::cout << "bingo\n";
	
	    for (int index = 0; index < group_size; index++){
	        //1
	        g = Group[index];
	        //2
	        for(int i = 0; i < m; i++){
	            //2.1
	            b = powmod(g, t/rank_G_factors[i], n);
	            //2.2
	            if(b == 1)
	                break;
	        }
	        //3
	        if(b != 1)
	            return g;
	    }
	}


	template <typename T>
	T primitive_root_modulo(T const& p, TypeSpecifications<T>& algo){
		std::vector<T> fact;
		T _phi = phi(p, algo);
		T n = _phi;

		fact.push_back(n);
		fact.push_back(1);
		factorize(n, fact, algo);
 
		for (T res=2; res<=p; ++res) {
			bool ok = true;
			if (algo.gcd(res, n) != 1) continue;
			for (size_t i=0; i<fact.size() && ok; ++i)
				ok &= (powmod (res, _phi / fact[i], p) != 1);
			if (ok)  return res;
		}
		return -1;
	}

}
